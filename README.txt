This is an implementation of Adaptive Huffman compression algorithm. It includes both encoder and decoder that run separately from each other. No data compression libs were used. This implementation does not give a gain in compression at all compared to the two-pass Huffman algorithm, so it can be improved. But the idea of using adaptive tree formation instesd of doing two passes just seems to be better or at least more interesting, so I gave it a try.

-----------------------------------------------------------------------------------------------------------------------------

Работа с бинарным деревом Хаффмана
1. В начале работы содержит только специальный символ (esc-символ), имеющий частоту 0.
2. Левые ветви дерева помечаются 0, а правые – 1.
3. При нарушении упорядоченности необходимо упорядочить.

Кодирование
1. Элементы входного сообщения считываются побайтно.
2. Если входной символ присутствует в дереве, в выходной поток записывается код, соответствующий последовательности 0 и 1, которыми помечены ветки дерева, при проходе от корня к данному листу. Вес листа увеличивается на 1. Веса узлов-предков корректируются. Если дерево становится неупорядоченным – упорядочивается.
3. Если входной символ отсутствует в дереве, в выходной поток записывается последовательность 0 и 1, которыми помечены ветки бинарного дерева при движении от корня к esc-символу, а затем 8 бит ASCII-кода нового символа. В дерево вместо esc-символа добавляется ветка: родитель, два потомка. Левый потомок – esc-символ, правый – новый добавленный в дерево символ. Веса узлов-предков корректируются, дерево при необходимости упорядочивается.

Декодирование
1. Элементы входного сообщения считываются побитно.
2. Каждый раз при считывании 0 или 1 происходит перемещение от корня вниз по соответствующей ветке бинарного дерева Хаффмана до тех пор, пока не будет достигнут какой-либо лист дерева.
3. Если достигнут лист, соответствующий символу, в выходное сообщение записывается ASCII-код этого символа. Вес листа увеличивается на 1, веса узлов-предков корректируются, дерево при необходимости упорядочивается.
4. Если же достигнут esc-символ, из входного сообщения считываются следующие 8 бит, соответствующие ASCII-коду нового символа. В выходное сообщение записывается этот ASCII-код. В дерево добавляется новый символ, веса узлов-предков корректируются. При необходимости дерево упорядочивается.
